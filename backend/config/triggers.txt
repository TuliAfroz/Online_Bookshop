--1.------------------------------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION process_order_on_insert()
RETURNS TRIGGER AS $$
DECLARE
  v_cart_id INT;
  v_subtotal FLOAT := 0;
  v_points INT := 0;
  v_level TEXT;
  v_point_discount_rate FLOAT := 0;
  v_gift_discount_rate FLOAT := 0;
  v_total_discount FLOAT := 0;
BEGIN
  -- 1. Get latest cart ID
  SELECT cart_id INTO v_cart_id
  FROM Cart
  WHERE customer_id = NEW.customer_id AND status=FALSE
  ORDER BY created_at DESC
  LIMIT 1;

  IF v_cart_id IS NULL THEN
    RAISE EXCEPTION 'No cart found for customer';
  END IF;

  -- 2. Calculate subtotal from CartItem
  SELECT COALESCE(SUM(quantity * per_item_price), 0)
  INTO v_subtotal
  FROM CartItem
  WHERE cart_id = v_cart_id;

  -- 3. Calculate potential gift card discount, do not delete yet
  --IF NEW.use_giftcard THEN
    --SELECT COALESCE(SUM(amount), 0)
    --INTO v_gift_discount_rate
    --FROM GiftCard
    --WHERE customer_id = NEW.customer_id;
  --END IF;

SELECT COALESCE(SUM(amount), 0)
INTO v_gift_discount_rate
FROM GiftCard g
JOIN UsedGiftCardsTemp u ON g.card_id = u.giftcard_id
WHERE g.customer_id = NEW.customer_id;


  -- 4. Calculate point discount rate based on level, but do not deduct yet
  IF NEW.use_points THEN
    SELECT point_count, level INTO v_points, v_level
    FROM Point
    WHERE customer_id = NEW.customer_id;

    IF v_points >= 300 THEN
      IF v_level = 'Silver' THEN
        v_point_discount_rate := 0.05;
      ELSIF v_level = 'Gold' THEN
        v_point_discount_rate := 0.10;
      ELSIF v_level = 'Platinum' THEN
        v_point_discount_rate := 0.15;
      END IF;
    END IF;
  END IF;

  -- 5. Calculate discount and payable amount
v_total_discount := (v_subtotal * v_point_discount_rate) + (v_subtotal * v_gift_discount_rate / 100);
  NEW.SubTotal_Price := v_subtotal;
  NEW.Discount := v_total_discount;
  NEW.Total_Price := v_subtotal - v_total_discount;


  UPDATE orders
SET
  subtotal_price =NEW.Subtotal_Price,
  discount = NEW.Discount,
  total_price = NEW.Total_price
WHERE order_id = NEW.order_id;


  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- On INSERT of an order------------------------
CREATE OR REPLACE TRIGGER trg_process_order
BEFORE INSERT ON Orders
FOR EACH ROW
EXECUTE FUNCTION process_order_on_insert();

--2.--------------------------------------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION handle_payment_post_insert()
RETURNS TRIGGER AS $$
DECLARE
  v_point INT;
  v_total_points INT;
  v_level TEXT;
  v_cart_id INT;
  v_order_id INT;
  v_customer_id INT;
  v_use_points BOOLEAN := FALSE;
  v_current_points INT;
BEGIN
  -- 1. Update admin's balance
  UPDATE Admin
  SET balance = COALESCE(balance, 0) + NEW.amount
  WHERE Admin_ID = NEW.receiver_admin_id;

  -- 2. Get order info
  SELECT Order_ID, Customer_ID, COALESCE(use_points, FALSE)
  INTO v_order_id, v_customer_id, v_use_points
  FROM Orders
  WHERE Order_ID = NEW.order_id;

  -- 3. If payer_customer_id is present, handle points logic
  IF NEW.payer_customer_id IS NOT NULL THEN

    -- Deduct 300 points if used
    IF v_use_points THEN
      SELECT Point_count INTO v_current_points
      FROM Point
      WHERE Customer_ID = v_customer_id;

      IF v_current_points >= 300 THEN
        UPDATE Point
        SET Point_count = Point_count - 300
        WHERE Customer_ID = v_customer_id;
      END IF;
    END IF;

    -- Delete used gift cards
    DELETE FROM GiftCard
    WHERE Card_ID IN (
      SELECT giftcard_id
      FROM UsedGiftCardsTemp
      WHERE customer_id = NEW.payer_customer_id
    );

    -- Add earned points (max 250)
    v_point := FLOOR(RANDOM() * LEAST(NEW.amount / 5, 250)) + 1;

    UPDATE Point
    SET Point_count = Point_count + v_point
    WHERE Customer_ID = v_customer_id;

    IF NOT FOUND THEN
      INSERT INTO Point(Customer_ID, Point_count, Level)
      VALUES (v_customer_id, v_point, 'Silver');
    END IF;

    -- Recalculate level
    SELECT Point_count INTO v_total_points
    FROM Point WHERE Customer_ID = v_customer_id;

    IF v_total_points < 301 THEN
      v_level := 'Silver';
    ELSIF v_total_points < 601 THEN
      v_level := 'Gold';
    ELSE
      v_level := 'Platinum';
    END IF;

    UPDATE Point SET Level = v_level WHERE Customer_ID = v_customer_id;

    -- Save earned points to payment row
    UPDATE payment
    SET points_earned = v_point
    WHERE payer_customer_id = NEW.payer_customer_id AND order_id = NEW.order_id;

  END IF;

  -- 4. Update cart status
  SELECT cart_id INTO v_cart_id
  FROM Orders
  WHERE order_id = NEW.order_id;

  IF v_cart_id IS NOT NULL THEN
    UPDATE cart
    SET status = TRUE
    WHERE cart_id = v_cart_id;
  END IF;

  RETURN NULL;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE TRIGGER trg_handle_payment
AFTER INSERT ON Payment
FOR EACH ROW
EXECUTE FUNCTION handle_payment_post_insert();

--3.-----------------------------------------------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION enforce_review_purchase_check()
RETURNS TRIGGER AS $$
DECLARE
    purchase_count INT;
BEGIN
    SELECT COUNT(*) INTO purchase_count
    FROM orders o
    JOIN cartitem ci ON ci.cart_id = o.cart_id
    JOIN cart c ON c.cart_id = o.cart_id
    WHERE o.customer_id = NEW.customer_id
      AND ci.book_id = NEW.book_id
      AND c.status = TRUE;  -- Only count purchased carts

    IF purchase_count = 0 THEN
        RAISE EXCEPTION 'Customer % has not purchased book %', NEW.customer_id, NEW.book_id;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE TRIGGER trg_review_purchase_check
BEFORE INSERT OR UPDATE ON review
FOR EACH ROW
EXECUTE FUNCTION enforce_review_purchase_check();


--4.-----------------------------------------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION update_book_average_rating()
RETURNS TRIGGER AS $$
BEGIN
  -- Recalculate average rating for the book
  UPDATE book
  SET average_rating = (
    SELECT ROUND(AVG(rating)::numeric, 2)
    FROM review
    WHERE review.book_id = NEW.book_id
  )
  WHERE book.book_id = NEW.book_id;

  RETURN NULL;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE TRIGGER trg_update_book_rating_after_insert
AFTER INSERT OR UPDATE ON review
FOR EACH ROW
EXECUTE FUNCTION update_book_average_rating();

--5.------------------------------------------------------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION update_book_average_rating_delete()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE book
  SET average_rating = (
    SELECT ROUND(AVG(rating)::numeric, 2)
    FROM review
    WHERE review.book_id = OLD.book_id
  )
  WHERE book.book_id = OLD.book_id;

  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER trg_update_book_rating_after_delete
AFTER DELETE ON review
FOR EACH ROW
EXECUTE FUNCTION update_book_average_rating_delete();


--6.-------------------------------------------------------------------------------------------------------------------------------
-- Trigger Function: Before inserting into publisher_order (validate balance and apply discount)
CREATE OR REPLACE FUNCTION validate_and_place_publisher_order()
RETURNS TRIGGER AS $$
DECLARE
    final_amount NUMERIC;
    admin_balance NUMERIC;
BEGIN
    -- Apply 5% discount
    final_amount := NEW.total_amount * 0.95;

    -- Get balance of admin 101
    SELECT balance INTO admin_balance FROM admin WHERE admin_id = 101;

    IF final_amount > admin_balance THEN
        RAISE EXCEPTION 'Insufficient balance in admin 101''s account. Cannot place order.';
    END IF;

    -- Update order total to discounted value
    NEW.total_amount := final_amount;
    NEW.status := 'pending';

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER trg_validate_and_place_publisher_order
BEFORE INSERT ON publisher_order
FOR EACH ROW
EXECUTE FUNCTION validate_and_place_publisher_order();

--7.-----------------------------------------------------------------------------------------------------------------
-- Trigger Function: After publisher confirms the order
CREATE OR REPLACE FUNCTION notify_admin_to_pay()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.status = 'confirmed' THEN
        RAISE NOTICE 'Order % confirmed. Admin should now proceed to payment.', NEW.publisher_order_id;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER trg_notify_admin_to_pay
AFTER UPDATE ON publisher_order
FOR EACH ROW
WHEN (OLD.status = 'pending' AND NEW.status = 'confirmed')
EXECUTE FUNCTION notify_admin_to_pay();

--8.---------------------------------------------------------------------------------------------------------------------
-- Trigger Function: After payment, deduct balance and update inventory
CREATE OR REPLACE FUNCTION handle_payment_post_insert_pub()
RETURNS TRIGGER AS $$
DECLARE
    b_id INT;
    qty INT;
    pub_id INT;
BEGIN
    IF NEW.publisher_order_id IS NOT NULL THEN
        -- Deduct from admin 101's balance
        UPDATE admin
        SET balance = balance - NEW.amount
        WHERE admin_id = 101;

         -- Get the publisher ID from the order
        SELECT publisher_id INTO pub_id
        FROM publisher_order
        WHERE publisher_order_id = NEW.publisher_order_id;

        -- Add to the publisher's balance
        UPDATE publisher
        SET balance = balance + NEW.amount
        WHERE publisher_id = pub_id;

        -- Update inventory for each book in the order
        FOR b_id, qty IN
            SELECT book_id, quantity
            FROM publisher_order_item
            WHERE publisher_order_id = NEW.publisher_order_id
        LOOP
            UPDATE inventory
            SET quantity = quantity + qty
            WHERE book_id = b_id;
        END LOOP;

        -- Update order status to completed
        UPDATE publisher_order
        SET status = 'completed'
        WHERE publisher_order_id = NEW.publisher_order_id;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Re-create the trigger if needed
CREATE OR REPLACE TRIGGER trg_handle_payment_pub
AFTER INSERT ON payment
FOR EACH ROW
EXECUTE FUNCTION handle_payment_post_insert_pub();

--9.-------------------------------------------------------------------------------------------------------------------------------------
-- Trigger Function: Before update to cancel order
CREATE OR REPLACE FUNCTION prevent_cancel_after_payment()
RETURNS TRIGGER AS $$
DECLARE
    payment_exists BOOLEAN;
BEGIN
    SELECT EXISTS (
        SELECT 1 FROM payment
        WHERE publisher_order_id = OLD.publisher_order_id
    ) INTO payment_exists;

    IF payment_exists THEN
        RAISE EXCEPTION 'Cannot cancel an order after payment has been made.';
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER trg_prevent_cancel_after_payment
BEFORE UPDATE ON publisher_order
FOR EACH ROW
WHEN (NEW.status = 'cancelled')
EXECUTE FUNCTION prevent_cancel_after_payment();




